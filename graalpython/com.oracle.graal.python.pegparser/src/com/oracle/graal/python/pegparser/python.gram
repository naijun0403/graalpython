# Copyright (c) 2021, 2022, Oracle and/or its affiliates.
# Copyright (C) 1996-2021 Python Software Foundation
#
# Licensed under the PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
#
# PEG grammar for Java

#changes from c gramammar:
#   added java specific meta data @package, @parser_fields,
#   default rule is renamed to default_param

@license '''/*
 * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
'''

@package '''
com.oracle.graal.python.pegparser
'''

@imports '''
import com.oracle.graal.python.pegparser.sst.*;
import com.oracle.graal.python.pegparser.tokenizer.Token;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
'''

@parser_fields '''
'''

@trailer '''
    @Override
    protected SSTNode runParser(InputType inputType) {
        SSTNode result = null;
        switch (inputType) {
            case FILE:
                return file_rule();
            case SINGLE:
                return interactive_rule();
            case EVAL:
                return eval_rule();
            case FUNCTION_TYPE:
                return func_type_rule();
            case FSTRING:
                return fstring_rule();
        }
        return result;
    }
'''
file[mod_ty]: a=[statements] ENDMARKER { factory.createModule(a, startToken.startOffset, endToken.endOffset) }
interactive[mod_ty]: a=statement_newline { factory.createInteractiveModule(a, startToken.startOffset, endToken.endOffset) }
eval[mod_ty]: a=expressions NEWLINE* ENDMARKER { factory.createExpressionModule(a, startToken.startOffset, endToken.endOffset) }
func_type[mod_ty]: '(' a=[type_expressions] ')' '->' b=expression NEWLINE* ENDMARKER { _PyAST_FunctionType(a, b, p->arena) }
fstring[expr_ty]: star_expressions

# type_expressions allow */** but ignore them
type_expressions[asdl_expr_seq*]:
    | a=','.expression+ ',' '*' b=expression ',' '**' c=expression {
        this.appendToEnd(this.appendToEnd(a, b), c) }
    | a=','.expression+ ',' '*' b=expression { this.appendToEnd(a, b) }
    | a=','.expression+ ',' '**' b=expression { this.appendToEnd(a, b) }
    | '*' a=expression ',' '**' b=expression {
        this.appendToEnd(new ExprTy[] {a}, b) }
    | '*' a=expression { new ExprTy[] {a} }
    | '**' a=expression { new ExprTy[] {a} }
    | a[asdl_expr_seq*]=','.expression+ {a}

statements[asdl_stmt_seq*]: a=statement+ { a }
statement[asdl_stmt_seq*]:
    | a=compound_stmt { new StmtTy[]{a} }
    | a[asdl_stmt_seq*]=simple_stmts { a }
statement_newline[asdl_stmt_seq*]:
    | a=compound_stmt NEWLINE { new StmtTy[] {a} }
    | simple_stmts
    | NEWLINE { new StmtTy[] {factory.createPass(startToken.startOffset, endToken.endOffset)} }
    | ENDMARKER { _PyPegen_interactive_exit(p) }
simple_stmts[asdl_stmt_seq*]:
    | a=simple_stmt !';' NEWLINE {
            new StmtTy[] {a}; } # Not needed, there for speedup
    | a[asdl_stmt_seq*]=';'.simple_stmt+ [';'] NEWLINE { a }
# NOTE: assignment MUST precede expression, else parsing a simple assignment
# will throw a SyntaxError.
simple_stmt[stmt_ty] (memo):
    | assignment
    | e=star_expressions   { factory.createExpression(e) }
    | &'return' return_stmt
    | &('import' | 'from') import_stmt
    | &'raise' raise_stmt
    | 'pass' { factory.createPass(startToken.startOffset, endToken.endOffset) }
    | &'del' del_stmt
    | &'yield' yield_stmt
    | &'assert' assert_stmt
    | 'break' { factory.createBreak(startToken.startOffset, endToken.endOffset) }
    | 'continue' { factory.createContinue(startToken.startOffset, endToken.endOffset) }
    | &'global' global_stmt
    | &'nonlocal' nonlocal_stmt
compound_stmt[stmt_ty]:
    | &('def' | '@' | ASYNC) function_def
    | &'if' if_stmt
    | &('class' | '@') class_def
    | &('with' | ASYNC) with_stmt
    | &('for' | ASYNC) for_stmt
    | &'try' try_stmt
    | &'while' while_stmt
    | match_stmt

# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'
assignment[stmt_ty]:
    | a=NAME ':' b=expression c=['=' d=annotated_rhs { d }] {
        factory.createAnnAssignment(
                    setExprContext(a, ExprContext.Store),
                    b,
                    (ExprTy)c, true, startToken.startOffset, endToken.endOffset);
        }
    | a=('(' b=single_target ')' { b }
         | single_subscript_attribute_target) ':' b=expression c=['=' d=annotated_rhs { d }] {
        CHECK_VERSION(stmt_ty, 6, "Variable annotations syntax is", _PyAST_AnnAssign(a, b, c, 0, EXTRA)) }
    | a[asdl_expr_seq*]=(z=star_targets '=' { z })+ b=(yield_expr | star_expressions) !'=' tc=[TYPE_COMMENT] {
         factory.createAssignment(a, (ExprTy)b, newTypeComment((Token) tc), startToken.startOffset, endToken.endOffset) }
    | a=single_target b=augassign ~ c=(yield_expr | star_expressions) {
         factory.createAugAssignment(a, b, (ExprTy)c, startToken.startOffset, endToken.endOffset) }
    | invalid_assignment

augassign[AugOperator*]:
    | '+=' { ExprTy.BinOp.Operator.ADD }
    | '-=' { ExprTy.BinOp.Operator.SUB }
    | '*=' { ExprTy.BinOp.Operator.MULT }
    | '@=' { ExprTy.BinOp.Operator.MATMULT }
    | '/=' { ExprTy.BinOp.Operator.DIV }
    | '%=' { ExprTy.BinOp.Operator.MOD }
    | '&=' { ExprTy.BinOp.Operator.BITAND }
    | '|=' { ExprTy.BinOp.Operator.BITOR }
    | '^=' { ExprTy.BinOp.Operator.BITXOR }
    | '<<=' { ExprTy.BinOp.Operator.LSHIFT }
    | '>>=' { ExprTy.BinOp.Operator.RSHIFT }
    | '**=' { ExprTy.BinOp.Operator.POW }
    | '//=' { ExprTy.BinOp.Operator.FLOORDIV }

global_stmt[stmt_ty]: 'global' a[asdl_expr_seq*]=','.NAME+ {
    factory.createGlobal(extractNames(a), startToken.startOffset, endToken.endOffset) }
nonlocal_stmt[stmt_ty]: 'nonlocal' a[asdl_expr_seq*]=','.NAME+ {
    factory.createNonLocal(extractNames(a), startToken.startOffset, endToken.endOffset) }

yield_stmt[stmt_ty]: y=yield_expr { factory.createExpression(y) }

assert_stmt[stmt_ty]: 'assert' a=expression b=[',' z=expression { z }] { factory.createAssert(a, b, startToken.startOffset, endToken.endOffset) }

del_stmt[stmt_ty]:
    | 'del' a=del_targets &(';' | NEWLINE) { factory.createDelete(a, startToken.startOffset, endToken.endOffset) }
    | invalid_del_stmt

import_stmt[stmt_ty]: import_name | import_from
import_name[stmt_ty]: 'import' a=dotted_as_names { factory.createImport(a, startToken.startOffset, endToken.endOffset) }
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from[stmt_ty]:
    | 'from' a=('.' | '...')* b=dotted_name 'import' c=import_from_targets {
        factory.createImportFrom(((ExprTy.Name)b).id, c, countDots(a), startToken.startOffset, endToken.endOffset) }
    | 'from' a=('.' | '...')+ 'import' b=import_from_targets {
        factory.createImportFrom(null, b, countDots(a), startToken.startOffset, endToken.endOffset) }
import_from_targets[asdl_alias_seq*]:
    | '(' a=import_from_as_names [','] ')' { a }
    | import_from_as_names !','
    | '*' { new AliasTy[] {factory.createAlias("*", null, startToken.startOffset, endToken.endOffset)} }
    | invalid_import_from_targets
import_from_as_names[asdl_alias_seq*]:
    | a[asdl_alias_seq*]=','.import_from_as_name+ { a }
import_from_as_name[alias_ty]:
    | a=NAME b=['as' z=NAME { z }] { factory.createAlias(((ExprTy.Name)a).id,
                                               b == null ? null : ((ExprTy.Name)b).id,
                                               startToken.startOffset, endToken.endOffset) }
dotted_as_names[asdl_alias_seq*]:
    | a[asdl_alias_seq*]=','.dotted_as_name+ { a }
dotted_as_name[alias_ty]:
    | a=dotted_name b=['as' z=NAME { z }] { factory.createAlias(((ExprTy.Name)a).id,
                                                      b == null ? null : ((ExprTy.Name)b).id,
                                                      startToken.startOffset, endToken.endOffset) }
dotted_name[expr_ty]:
    | a=dotted_name '.' b=NAME { this.joinNamesWithDot(a, b) }
    | NAME

if_stmt[stmt_ty]:
    | 'if' a=named_expression ':' b=block c=elif_stmt {
        factory.createIf(a, b, new StmtTy[] {c}, startToken.startOffset, endToken.endOffset) }
    | 'if' a=named_expression ':' b=block c=[else_block] { factory.createIf(a, b, c, startToken.startOffset, endToken.endOffset) }
    | invalid_if_stmt
elif_stmt[stmt_ty]:
    | 'elif' a=named_expression ':' b=block c=elif_stmt {
        factory.createIf(a, b, new StmtTy[] {c}, startToken.startOffset, endToken.endOffset) }
    | 'elif' a=named_expression ':' b=block c=[else_block] { factory.createIf(a, b, c, startToken.startOffset, endToken.endOffset) }
    | invalid_elif_stmt
else_block[asdl_stmt_seq*]: 'else' &&':' b=block { b }

while_stmt[stmt_ty]:
    | 'while' a=named_expression ':' b=block c=[else_block] { factory.createWhile(a, b, c, startToken.startOffset, endToken.endOffset) }
    | invalid_while_stmt

for_stmt[stmt_ty]:
    | 'for' t=star_targets 'in' ~ ex=star_expressions &&':' tc=[TYPE_COMMENT] b=block el=[else_block] {
        factory.createFor(t, ex, b, el, newTypeComment(tc), startToken.startOffset, endToken.endOffset) }
    | ASYNC 'for' t=star_targets 'in' ~ ex=star_expressions &&':' tc=[TYPE_COMMENT] b=block el=[else_block] {
        CHECK_VERSION(stmt_ty, 5, "Async for loops are", _PyAST_AsyncFor(t, ex, b, el, NEW_TYPE_COMMENT(p, tc), EXTRA)) }
    | invalid_for_target

with_stmt[stmt_ty]:
    | 'with' '(' a[asdl_withitem_seq*]=','.with_item+ ','? ')' ':' b=block {
        factory.createWith(a, b, null, startToken.startOffset, endToken.endOffset) }
    | 'with' a[asdl_withitem_seq*]=','.with_item+ ':' tc=[TYPE_COMMENT] b=block {
        factory.createWith(a, b, newTypeComment(tc), startToken.startOffset, endToken.endOffset) }
    | ASYNC 'with' '(' a[asdl_withitem_seq*]=','.with_item+ ','? ')' ':' b=block {
       CHECK_VERSION(stmt_ty, 5, "Async with statements are", _PyAST_AsyncWith(a, b, NULL, EXTRA)) }
    | ASYNC 'with' a[asdl_withitem_seq*]=','.with_item+ ':' tc=[TYPE_COMMENT] b=block {
       CHECK_VERSION(stmt_ty, 5, "Async with statements are", _PyAST_AsyncWith(a, b, NEW_TYPE_COMMENT(p, tc), EXTRA)) }
    | invalid_with_stmt

with_item[withitem_ty]:
    | e=expression 'as' t=star_target &(',' | ')' | ':') { factory.createWithItem(e, t, startToken.startOffset,endToken.endOffset) }
    | invalid_with_item
    | e=expression { factory.createWithItem(e, null, startToken.startOffset,endToken.endOffset) }

try_stmt[stmt_ty]:
    | 'try' &&':' b=block f=finally_block { factory.createTry(b, null, null, f, startToken.startOffset, startToken.endOffset) }
    | 'try' &&':' b=block ex[asdl_excepthandler_seq*]=except_block+ el=[else_block] f=[finally_block] { factory.createTry(b, ex, el, f, startToken.startOffset, startToken.endOffset) }
except_block[excepthandler_ty]:
    | 'except' e=expression t=['as' z=NAME { z }] ':' b=block {
        factory.createExceptHandler(e, t != null ? ((ExprTy.Name)t).id : null, b, startToken.startOffset, startToken.endOffset) }
    | 'except' ':' b=block { factory.createExceptHandler(null, null, b, startToken.startOffset, startToken.endOffset) }
    | invalid_except_block
finally_block[asdl_stmt_seq*]: 'finally' ':' a=block { a }

match_stmt[stmt_ty]:
    | "match" subject=subject_expr ':' NEWLINE INDENT cases[asdl_match_case_seq*]=case_block+ DEDENT {
        CHECK_VERSION(stmt_ty, 10, "Pattern matching is", _PyAST_Match(subject, cases, EXTRA)) }
    | invalid_match_stmt
subject_expr[expr_ty]:
    | value=star_named_expression ',' values=star_named_expressions? {
        _PyAST_Tuple(CHECK(asdl_expr_seq*, this.insertInFront(value, values)), Load, EXTRA) }
    | named_expression
case_block[match_case_ty]:
    | "case" pattern=patterns guard=guard? ':' body=block {
        _PyAST_match_case(pattern, guard, body, p->arena) }
    | invalid_case_block
guard[expr_ty]: 'if' guard=named_expression { guard }

patterns[expr_ty]:
    | values[asdl_expr_seq*]=open_sequence_pattern {
        _PyAST_Tuple(values, Load, EXTRA) }
    | pattern
pattern[expr_ty]:
    | as_pattern
    | or_pattern
as_pattern[expr_ty]:
    | pattern=or_pattern 'as' target=capture_pattern {
        _PyAST_MatchAs(pattern, target->v.Name.id, EXTRA) }
or_pattern[expr_ty]:
    | patterns[asdl_expr_seq*]='|'.closed_pattern+ {
        asdl_seq_LEN(patterns) == 1 ? asdl_seq_GET(patterns, 0) : _PyAST_MatchOr(patterns, EXTRA) }
closed_pattern[expr_ty]:
    | literal_pattern
    | capture_pattern
    | wildcard_pattern
    | value_pattern
    | group_pattern
    | sequence_pattern
    | mapping_pattern
    | class_pattern

literal_pattern[expr_ty]:
    | signed_number !('+' | '-')
    | real=signed_number '+' imag=NUMBER { factory.createBinaryOp(ExprTy.BinOp.Operator.ADD, real, imag, startToken.startOffset, endToken.endOffset ) }
    | real=signed_number '-' imag=NUMBER  { factory.createBinaryOp(ExprTy.BinOp.Operator.SUB, real, imag, startToken.startOffset, endToken.endOffset ) }
    | strings
    | 'None' { factory.createNone(startToken.startOffset, startToken.endOffset) }
    | 'True' { factory.createBooleanLiteral(true, startToken.startOffset, startToken.endOffset) }
    | 'False' { factory.createBooleanLiteral(false, startToken.startOffset, startToken.endOffset) }
signed_number[expr_ty]:
    | NUMBER
    | '-' number=NUMBER { factory.createUnaryOp(ExprTy.UnaryOp.Operator.SUB, number, startToken.startOffset, endToken.endOffset) }

capture_pattern[expr_ty]:
    | !"_" name=NAME !('.' | '(' | '=') {
        _PyPegen_set_expr_context(p, name, Store) }

wildcard_pattern[expr_ty]:
    | "_" { _PyAST_Name(CHECK(PyObject*, _PyPegen_new_identifier(p, "_")), Store, EXTRA) }

value_pattern[expr_ty]:
    | attr=attr !('.' | '(' | '=') { attr }
attr[expr_ty]:
    | value=name_or_attr '.' attr=NAME { factory.createGetAttribute(value, ((ExprTy.Name)attr).id, startToken.startOffset, startToken.endOffset)}
name_or_attr[expr_ty]:
    | attr
    | NAME

group_pattern[expr_ty]:
    | '(' pattern=pattern ')' { pattern }

sequence_pattern[expr_ty]:
    | '[' values=maybe_sequence_pattern? ']' { _PyAST_List(values, Load, EXTRA) }
    | '(' values=open_sequence_pattern? ')' { _PyAST_Tuple(values, Load, EXTRA) }
open_sequence_pattern[asdl_seq*]:
    | value=maybe_star_pattern ',' values=maybe_sequence_pattern? {
        this.insertInFront(value, values) }
maybe_sequence_pattern[asdl_seq*]:
    | values=','.maybe_star_pattern+ ','? { values }
maybe_star_pattern[expr_ty]:
    | star_pattern
    | pattern
star_pattern[expr_ty]:
    | '*' value=(capture_pattern | wildcard_pattern) {
        factory.createStarred(value, ExprContext.Store, startToken.startOffset, endToken.endOffset) }

mapping_pattern[expr_ty]:
    | '{' items=items_pattern? '}' {
        _PyAST_Dict(CHECK(asdl_expr_seq*, _PyPegen_get_keys(p, items)), CHECK(asdl_expr_seq*, _PyPegen_get_values(p, items)), EXTRA) }
items_pattern[asdl_seq*]:
    | items=','.key_value_pattern+ ','? { items }
key_value_pattern[KeyValuePair*]:
    | key=(literal_pattern | value_pattern) ':' value=pattern {
        new KeyValuePair(key, value) }
    | double_star_pattern
double_star_pattern[KeyValuePair*]:
    | '**' value=capture_pattern { KeyValuePair(null, value) }

class_pattern[expr_ty]:
    | func=name_or_attr '(' ')' { _PyAST_Call(func, NULL, NULL, EXTRA) }
    | func=name_or_attr '(' args=positional_patterns ','? ')' {
        _PyAST_Call(func, args, NULL, EXTRA) }
    | func=name_or_attr '(' keywords=keyword_patterns ','? ')' {
        _PyAST_Call(func, NULL, keywords, EXTRA) }
    | func=name_or_attr '(' args=positional_patterns ',' keywords=keyword_patterns ','? ')' {
        _PyAST_Call(func, args, keywords, EXTRA) }
positional_patterns[asdl_expr_seq*]:
    | args[asdl_expr_seq*]=','.pattern+ { args }
keyword_patterns[asdl_keyword_seq*]:
    | keywords[asdl_keyword_seq*]=','.keyword_pattern+ { keywords }
keyword_pattern[keyword_ty]:
    | arg=NAME '=' value=pattern { _PyAST_keyword(arg->v.Name.id, value, EXTRA) }

return_stmt[stmt_ty]:
    | 'return' a=[star_expressions] { factory.createReturn(a, startToken.startOffset, endToken.endOffset) }

raise_stmt[stmt_ty]:
    | 'raise' a=expression b=['from' z=expression { z }] { factory.createRaise(a, b, startToken.startOffset, endToken.endOffset) }
    | 'raise' { factory.createRaise(null, null, startToken.startOffset, endToken.endOffset) }

function_def[stmt_ty]:
    | d=decorators f=function_def_raw { factory.createFunctionDefWithDecorators(f, d) }
    | function_def_raw

function_def_raw[stmt_ty]:
    | 'def' n=NAME '(' params=[params] ')' a=['->' z=expression { z }] &&':' tc=[func_type_comment] b=block {
        factory.createFunctionDef(((ExprTy.Name)n).id,
                        params,
                        b, (ExprTy)a, newTypeComment((Token)tc),
                        startToken.startOffset, endToken.endOffset) }
    | ASYNC 'def' n=NAME '(' params=[params] ')' a=['->' z=expression { z }] &&':' tc=[func_type_comment] b=block {
        checkVersion(
            5,
            "Async functions are",
            factory.createAsyncFunctionDef(((ExprTy.Name)n).id,
                            params,
                            b, a, newTypeComment((Token)tc), startToken.startOffset, endToken.endOffset)
        ) }
func_type_comment[Token*]:
    | NEWLINE t=TYPE_COMMENT &(NEWLINE INDENT) { t }  # Must be followed by indented block
    | invalid_double_type_comments
    | TYPE_COMMENT

params[arguments_ty]:
    | invalid_parameters
    | parameters

parameters[arguments_ty]:
    | a=slash_no_default b[asdl_arg_seq*]=param_no_default* c=param_with_default* d=[star_etc] {
        factory.createArguments(a, null, b, c, d) }
    | a=slash_with_default b=param_with_default* c=[star_etc] {
        factory.createArguments(null, a, null, b, c) }
    | a[asdl_arg_seq*]=param_no_default+ b=param_with_default* c=[star_etc] {
        factory.createArguments(null, null, a, b, c) }
    | a=param_with_default+ b=[star_etc] { factory.createArguments(null, null, null, a, b)}
    | a=star_etc { factory.createArguments(null, null, null, null, a) }

# Some duplication here because we can't write (',' | &')'),
# which is because we don't support empty alternatives (yet).
#
slash_no_default[asdl_arg_seq*]:
    | a[asdl_arg_seq*]=param_no_default+ '/' ',' { a }
    | a[asdl_arg_seq*]=param_no_default+ '/' &')' { a }
slash_with_default[SlashWithDefault*]:
    | a=param_no_default* b=param_with_default+ '/' ',' { new SlashWithDefault(a, b) }
    | a=param_no_default* b=param_with_default+ '/' &')' { new SlashWithDefault(a, b) }

star_etc[StarEtc*]:
    | '*' a=param_no_default b=param_maybe_default* c=[kwds] {
        new StarEtc(a, b, c) }
    | '*' ',' b=param_maybe_default+ c=[kwds] {
        new StarEtc(null, b, c) }
    | a=kwds { new StarEtc(null, null, a) }
    | invalid_star_etc

kwds[arg_ty]: '**' a=param_no_default { a }

# One parameter.  This *includes* a following comma and type comment.
#
# There are three styles:
# - No default
# - With default
# - Maybe with default
#
# There are two alternative forms of each, to deal with type comments:
# - Ends in a comma followed by an optional type comment
# - No comma, optional type comment, must be followed by close paren
# The latter form is for a final parameter without trailing comma.
#
param_no_default[arg_ty]:
    | a=param ',' tc=TYPE_COMMENT? { factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()) }
    | a=param tc=TYPE_COMMENT? &')' { factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()) }
param_with_default[NameDefaultPair*]:
    | a=param c=default_param ',' tc=TYPE_COMMENT? { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()), c) }
    | a=param c=default_param tc=TYPE_COMMENT? &')' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()), c) }
param_maybe_default[NameDefaultPair*]:
    | a=param c=default_param? ',' tc=TYPE_COMMENT? { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()), c) }
    | a=param c=default_param? tc=TYPE_COMMENT? &')' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, newTypeComment(tc), a.getStartOffset(), a.getEndOffset()), c) }
param[arg_ty]: a=NAME b=annotation? { factory.createArgument(((ExprTy.Name)a).id, b, null, startToken.startOffset, startToken.endOffset) }

annotation[expr_ty]: ':' a=expression { a }
default_param[expr_ty]: '=' a=expression { a }

decorators[asdl_expr_seq*]: a[asdl_expr_seq*]=('@' f=named_expression NEWLINE { f })+ { a }

class_def[stmt_ty]:
    | a=decorators b=class_def_raw { factory.createClassDef(b, a, startToken.startOffset, endToken.endOffset) }
    | class_def_raw
class_def_raw[stmt_ty]:
    | 'class' a=NAME b=['(' z=[arguments] ')' { z }] &&':' c=block {
        factory.createClassDef(a, b, c, startToken.startOffset, endToken.endOffset) }

block[asdl_stmt_seq*] (memo):
    | NEWLINE INDENT a=statements DEDENT { a }
    | simple_stmts
    | invalid_block

star_expressions[expr_ty]:
    | a=star_expression b=(',' c=star_expression { c })+ [','] {
        factory.createTuple(this.insertInFront(a, b), ExprContext.Load, startToken.startOffset, endToken.endOffset) }
    | a=star_expression ',' { factory.createTuple(new ExprTy[] {a}, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
    | star_expression
star_expression[expr_ty] (memo):
    | '*' a=bitwise_or { factory.createStarred(a, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
    | expression

star_named_expressions[asdl_expr_seq*]: a[asdl_expr_seq*]=','.star_named_expression+ [','] { a }
star_named_expression[expr_ty]:
    | '*' a=bitwise_or { factory.createStarred(a, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
    | named_expression

named_expression[expr_ty]:
    | a=NAME ':=' ~ b=expression { factory.createNamedExp(this.check(this.setExprContext(a, ExprContext.Store)), b, startToken.startOffset, endToken.endOffset) }
    | invalid_named_expression
    | expression !':='

direct_named_expression[expr_ty]:
    | a=NAME ':=' ~ b=expression { factory.createNamedExp(this.check(this.setExprContext(a, ExprContext.Store)), b, startToken.startOffset, endToken.endOffset) }
    | expression !':='

annotated_rhs[expr_ty]: yield_expr | star_expressions

expressions[expr_ty]:
    | a=expression b=(',' c=expression { c })+ [','] {
        _PyAST_Tuple(CHECK(asdl_expr_seq*, this.insertInFront(a, b)), Load, EXTRA) }
    | a=expression ',' { _PyAST_Tuple(CHECK(asdl_expr_seq*, new ExprTy[] {a}), Load, EXTRA) }
    | expression
expression[expr_ty] (memo):
    | invalid_expression
    | a=disjunction 'if' b=disjunction 'else' c=expression { factory.createIfExpression(b, a, c, startToken.startOffset, endToken.endOffset) }
    | disjunction
    | lambdef

lambdef[expr_ty]:
    | 'lambda' a=[lambda_params] ':' b=expression {
        factory.createLambda(a, b, startToken.startOffset, endToken.endOffset) }

lambda_params[arguments_ty]:
    | invalid_lambda_parameters
    | lambda_parameters

# lambda_parameters etc. duplicates parameters but without annotations
# or type comments, and if there's no comma after a parameter, we expect
# a colon, not a close parenthesis.  (For more, see parameters above.)
#
lambda_parameters[arguments_ty]:
    | a=lambda_slash_no_default b[asdl_arg_seq*]=lambda_param_no_default* c=lambda_param_with_default* d=[lambda_star_etc] {
        factory.createArguments(a, null, b, c, d) }
    | a=lambda_slash_with_default b=lambda_param_with_default* c=[lambda_star_etc] {
        factory.createArguments(null, a, null, b, c) }
    | a[asdl_arg_seq*]=lambda_param_no_default+ b=lambda_param_with_default* c=[lambda_star_etc] {
        factory.createArguments(null, null, a, b, c) }
    | a=lambda_param_with_default+ b=[lambda_star_etc] { factory.createArguments(null, null, null, a, b)}
    | a=lambda_star_etc { factory.createArguments(null, null, null, null, a) }

lambda_slash_no_default[asdl_arg_seq*]:
    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' ',' { a }
    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' &':' { a }
lambda_slash_with_default[SlashWithDefault*]:
    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' ',' { new SlashWithDefault(a, b) }
    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' &':' { new SlashWithDefault(a, b) }

lambda_star_etc[StarEtc*]:
    | '*' a=lambda_param_no_default b=lambda_param_maybe_default* c=[lambda_kwds] {
        new StarEtc(a, b, c) }
    | '*' ',' b=lambda_param_maybe_default+ c=[lambda_kwds] {
        new StarEtc(null, b, c) }
    | a=lambda_kwds { new StarEtc(null, null, a) }
    | invalid_lambda_star_etc

lambda_kwds[arg_ty]: '**' a=lambda_param_no_default { a }

lambda_param_no_default[arg_ty]:
    | a=lambda_param ',' { a }
    | a=lambda_param &':' { a }
lambda_param_with_default[NameDefaultPair*]:
    | a=lambda_param c=default_param ',' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, null, a.getStartOffset(), a.getEndOffset()), c) }
    | a=lambda_param c=default_param &':' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, null, a.getStartOffset(), a.getEndOffset()), c) }
lambda_param_maybe_default[NameDefaultPair*]:
    | a=lambda_param c=default_param? ',' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, null, a.getStartOffset(), a.getEndOffset()), c) }
    | a=lambda_param c=default_param? &':' { new NameDefaultPair(factory.createArgument(a.arg, a.annotation, null, a.getStartOffset(), a.getEndOffset()), c) }
lambda_param[arg_ty]: a=NAME { factory.createArgument(((ExprTy.Name)a).id, null, null, startToken.startOffset, endToken.endOffset) }

disjunction[expr_ty] (memo):
    | a=conjunction b=('or' c=conjunction { c })+ { factory.createOr(
        this.insertInFront(a, b),
        startToken.startOffset, endToken.endOffset) }
    | conjunction
conjunction[expr_ty] (memo):
    | a=inversion b=('and' c=inversion { c })+ { factory.createAnd(
        this.insertInFront(a, b),
        startToken.startOffset, endToken.endOffset) }
    | inversion
inversion[expr_ty] (memo):
    | 'not' a=inversion { factory.createUnaryOp(ExprTy.UnaryOp.Operator.NOT, a, startToken.startOffset, endToken.endOffset) }
    | comparison
comparison[expr_ty]:
    | a=bitwise_or b=compare_op_bitwise_or_pair+ {
         factory.createComparison(a, b, startToken.startOffset, endToken.endOffset) }
    | bitwise_or
compare_op_bitwise_or_pair[CmpopExprPair*]:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or
eq_bitwise_or[CmpopExprPair*]: '==' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.EQ, a); }
noteq_bitwise_or[CmpopExprPair*]:
    | (tok='!=' { this.checkBarryAsFlufl(tok) ? null : tok}) a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.NOTEQ, a) }
lte_bitwise_or[CmpopExprPair*]: '<=' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.LTE, a) }
lt_bitwise_or[CmpopExprPair*]: '<' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.LT, a) }
gte_bitwise_or[CmpopExprPair*]: '>=' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.GTE, a) }
gt_bitwise_or[CmpopExprPair*]: '>' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.GT, a) }
notin_bitwise_or[CmpopExprPair*]: 'not' 'in' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.NOTIN, a) }
in_bitwise_or[CmpopExprPair*]: 'in' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.IN, a) }
isnot_bitwise_or[CmpopExprPair*]: 'is' 'not' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.ISNOT, a) }
is_bitwise_or[CmpopExprPair*]: 'is' a=bitwise_or { new CmpopExprPair(ExprTy.Compare.Operator.IS, a) }

bitwise_or[expr_ty]:
    | a=bitwise_or '|' b=bitwise_xor { factory.createBinaryOp(ExprTy.BinOp.Operator.BITOR, a, b, startToken.startOffset, endToken.endOffset ) }
    | bitwise_xor
bitwise_xor[expr_ty]:
    | a=bitwise_xor '^' b=bitwise_and { factory.createBinaryOp(ExprTy.BinOp.Operator.BITXOR, a, b, startToken.startOffset, endToken.endOffset ) }
    | bitwise_and
bitwise_and[expr_ty]:
    | a=bitwise_and '&' b=shift_expr { factory.createBinaryOp(ExprTy.BinOp.Operator.BITAND, a, b, startToken.startOffset, endToken.endOffset ) }
    | shift_expr
shift_expr[expr_ty]:
    | a=shift_expr '<<' b=sum { factory.createBinaryOp(ExprTy.BinOp.Operator.LSHIFT, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=shift_expr '>>' b=sum { factory.createBinaryOp(ExprTy.BinOp.Operator.RSHIFT, a, b, startToken.startOffset, endToken.endOffset ) }
    | sum

sum[expr_ty]:
    | a=sum '+' b=term { factory.createBinaryOp(ExprTy.BinOp.Operator.ADD, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=sum '-' b=term { factory.createBinaryOp(ExprTy.BinOp.Operator.SUB, a, b, startToken.startOffset, endToken.endOffset ) }
    | term
term[expr_ty]:
    | a=term '*' b=factor { factory.createBinaryOp(ExprTy.BinOp.Operator.MULT, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=term '/' b=factor { factory.createBinaryOp(ExprTy.BinOp.Operator.DIV, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=term '//' b=factor { factory.createBinaryOp(ExprTy.BinOp.Operator.FLOORDIV, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=term '%' b=factor { factory.createBinaryOp(ExprTy.BinOp.Operator.MOD, a, b, startToken.startOffset, endToken.endOffset ) }
    | a=term '@' b=factor { checkVersion(5, "The '@' operator is", factory.createBinaryOp(ExprTy.BinOp.Operator.MATMULT, a, b, startToken.startOffset, endToken.endOffset )) }
    | factor
factor[expr_ty] (memo):
    | '+' a=factor {factory.createUnaryOp(ExprTy.UnaryOp.Operator.ADD, a, startToken.startOffset, endToken.endOffset)}
    | '-' a=factor {factory.createUnaryOp(ExprTy.UnaryOp.Operator.SUB, a, startToken.startOffset, endToken.endOffset)}
    | '~' a=factor {factory.createUnaryOp(ExprTy.UnaryOp.Operator.INVERT, a, startToken.startOffset, endToken.endOffset)}
    | power
power[expr_ty]:
    | a=await_primary '**' b=factor { factory.createBinaryOp(ExprTy.BinOp.Operator.POW, a, b, startToken.startOffset, endToken.endOffset ) }
    | await_primary
await_primary[expr_ty] (memo):
    | AWAIT a=primary { checkVersion(5, "Await expressions are", factory.createAwait(a, startToken.startOffset, endToken.endOffset)) }
    | primary
primary[expr_ty]:
    | invalid_primary  # must be before 'primay genexp' because of invalid_genexp
    | a=primary '.' b=NAME { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Load, startToken.startOffset, startToken.endOffset) }
    | a=primary b=genexp { factory.createCall(a, new ExprTy[] {b}, EMPTY_KWDS, startToken.startOffset, endToken.endOffset) }
    | a=primary '(' b=[arguments] ')' {
        factory.createCall(a, b != null ? ((ExprTy.Call)b).args : EMPTY_EXPR, b != null ? ((ExprTy.Call)b).keywords : EMPTY_KWDS, startToken.startOffset, endToken.endOffset) }
    | a=primary '[' b=slices ']' { factory.createSubscript(a, b, ExprContext.Load, startToken.startOffset, startToken.endOffset) }
    | atom

slices[expr_ty]:
    | a=slice !',' { a }
    | a[asdl_expr_seq*]=','.slice+ [','] { factory.createTuple(a, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
slice[expr_ty]:
    | a=[expression] ':' b=[expression] c=[':' d=[expression] { d }] { factory.createSlice(a, b, c, startToken.startOffset, endToken.endOffset) }
    | a=named_expression { a }
atom[expr_ty]:
    | NAME
    | 'True' { factory.createBooleanLiteral(true, startToken.startOffset, endToken.endOffset) }
    | 'False' { factory.createBooleanLiteral(false, startToken.startOffset, endToken.endOffset) }
    | 'None' { factory.createNone(startToken.startOffset, startToken.endOffset) }
    | &STRING strings
    | NUMBER
    | &'(' (tuple | group | genexp)
    | &'[' (list | listcomp)
    | &'{' (dict | set | dictcomp | setcomp)
    | '...' { factory.createEllipsis(startToken.startOffset, startToken.endOffset) }

strings[expr_ty] (memo): a=STRING+ { this.concatenateStrings(a) }
list[expr_ty]:
    | '[' a=[star_named_expressions] ']' { factory.createList(a, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
listcomp[expr_ty]:
    | '[' a=named_expression b=for_if_clauses ']' { factory.createListComprehension(a, b, startToken.startOffset, endToken.endOffset) }
    | invalid_comprehension
tuple[expr_ty]:
    | '(' a=[y=star_named_expression ',' z=[star_named_expressions] { this.insertInFront(y, z) } ] ')' {
        factory.createTuple((ExprTy[])a, ExprContext.Load, startToken.startOffset, endToken.endOffset) }
group[expr_ty]:
    | '(' a=(yield_expr | named_expression) ')' { a }
    | invalid_group
genexp[expr_ty]:
    | '(' a=direct_named_expression b=for_if_clauses ')' { factory.createGenerator(a, b, startToken.startOffset, endToken.endOffset) }
    | invalid_comprehension
set[expr_ty]: '{' a=star_named_expressions '}' { factory.createSet(a,startToken.startOffset,endToken.endOffset) }
setcomp[expr_ty]:
    | '{' a=named_expression b=for_if_clauses '}' { factory.createSetComprehension(a, b, startToken.startOffset, endToken.endOffset) }
    | invalid_comprehension
dict[expr_ty]:
    | '{' a=[double_starred_kvpairs] '}' {
        factory.createDict(extractKeys(a),extractValues(a),startToken.startOffset,endToken.endOffset) }
    | '{' invalid_double_starred_kvpairs '}'

dictcomp[expr_ty]:
    | '{' a=kvpair b=for_if_clauses '}' { factory.createDictComprehension(a, b, startToken.startOffset, endToken.endOffset) }
    | invalid_dict_comprehension
double_starred_kvpairs: a=','.double_starred_kvpair+ [','] { a }
double_starred_kvpair[KeyValuePair*]:
    | '**' a=bitwise_or { new KeyValuePair(null, a) }
    | kvpair
kvpair[KeyValuePair*]: a=expression ':' b=expression { new KeyValuePair(a, b) }
for_if_clauses[asdl_comprehension_seq*]:
    | a[asdl_comprehension_seq*]=for_if_clause+ { a }
for_if_clause[comprehension_ty]:
    | ASYNC 'for' a=star_targets 'in' ~ b=disjunction c[asdl_expr_seq*]=('if' z=disjunction { z })* {
        CHECK_VERSION(comprehension_ty, 6, "Async comprehensions are", _PyAST_comprehension(a, b, c, 1, p->arena)) }
    | 'for' a=star_targets 'in' ~ b=disjunction c[asdl_expr_seq*]=('if' z=disjunction { z })* {
        factory.createComprehension(a, b, c, false, startToken.startOffset, endToken.endOffset) }
    | invalid_for_target

yield_expr[expr_ty]:
    | 'yield' 'from' a=expression { factory.createYield(a, true, startToken.startOffset, endToken.endOffset) }
    | 'yield' a=[star_expressions] { factory.createYield(a, false, startToken.startOffset, endToken.endOffset) }

arguments[expr_ty] (memo):
    | a=args [','] &')' { a }
    | invalid_arguments
args[expr_ty]:
    | a[asdl_expr_seq*]=','.(starred_expression | direct_named_expression !'=')+ b=[',' k=kwargs {k}] { this.collectCallSequences(a,b,startToken.startOffset,endToken.endOffset) }
    | a=kwargs { factory.createCall(dummyName(),
                                    extractStarredExpressions(a),
                                    deleteStarredExpressions(a),
                                    startToken.startOffset, endToken.endOffset) }
kwargs[asdl_seq*]:
    | a=','.kwarg_or_starred+ ',' b=','.kwarg_or_double_starred+ { this.join(a, b) }
    | ','.kwarg_or_starred+
    | ','.kwarg_or_double_starred+
starred_expression[expr_ty]:
    | '*' a=expression { factory.createStarred(a, startToken.startOffset, endToken.endOffset) }
kwarg_or_starred[KeywordOrStarred*]:
    | a=NAME '=' b=expression { new KeywordOrStarred(factory.createKeyword(((ExprTy.Name)a).id, b, startToken.startOffset, endToken.endOffset), true) }
    | a=starred_expression { new KeywordOrStarred(a, false) }
    | invalid_kwarg
kwarg_or_double_starred[KeywordOrStarred*]:
    | a=NAME '=' b=expression { new KeywordOrStarred(factory.createKeyword(((ExprTy.Name)a).id, b, startToken.startOffset, endToken.endOffset), true) }
    | '**' a=expression { new KeywordOrStarred(factory.createKeyword(null, a, startToken.startOffset, endToken.endOffset), true) }
    | invalid_kwarg

# NOTE: star_targets may contain *bitwise_or, targets may not.
star_targets[expr_ty]:
    | a=star_target !',' { a }
    | a=star_target b=(',' c=star_target { c })* [','] {
        factory.createTuple(this.insertInFront(a,b),ExprContext.Store,startToken.startOffset,endToken.endOffset); }
star_targets_list_seq[asdl_expr_seq*]: a[asdl_expr_seq*]=','.star_target+ [','] { a }
star_targets_tuple_seq[asdl_expr_seq*]:
    | a=star_target b=(',' c=star_target { c })+ [','] { this.insertInFront(a, b) }
    | a=star_target ',' { new ExprTy[] {a} }
star_target[expr_ty] (memo):
    | '*' a=(!'*' star_target) {
        factory.createStarred(this.setExprContext(a, ExprContext.Store), ExprContext.Store, startToken.startOffset, endToken.endOffset)}
    | target_with_star_atom
target_with_star_atom[expr_ty] (memo):
    | a=t_primary '.' b=NAME !t_lookahead { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Store, startToken.startOffset, startToken.endOffset) }
    | a=t_primary '[' b=slices ']' !t_lookahead { factory.createSubscript(a, b, ExprContext.Store, startToken.startOffset, startToken.endOffset) }
    | star_atom
star_atom[expr_ty]:
    | a=NAME { this.setExprContext(a, ExprContext.Store) }
    | '(' a=target_with_star_atom ')' { this.setExprContext(a, ExprContext.Store) }
    | '(' a=[star_targets_tuple_seq] ')' { factory.createTuple(a, ExprContext.Store, startToken.startOffset, endToken.endOffset) }
    | '[' a=[star_targets_list_seq] ']' { factory.createList(a, ExprContext.Store, startToken.startOffset, endToken.endOffset) }

single_target[expr_ty]:
    | single_subscript_attribute_target
    | a=NAME  { this.setExprContext(a, ExprContext.Store) }
    | '(' a=single_target ')' { a }
single_subscript_attribute_target[expr_ty]:
    | a=t_primary '.' b=NAME !t_lookahead { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Store, startToken.startOffset, startToken.endOffset) }
    | a=t_primary '[' b=slices ']' !t_lookahead { factory.createSubscript(a, b, ExprContext.Store, startToken.startOffset, startToken.endOffset) }

del_targets[asdl_expr_seq*]: a[asdl_expr_seq*]=','.del_target+ [','] { a }
del_target[expr_ty] (memo):
    | a=t_primary '.' b=NAME !t_lookahead { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Delete, startToken.startOffset, startToken.endOffset) }
    | a=t_primary '[' b=slices ']' !t_lookahead { factory.createSubscript(a, b, ExprContext.Delete, startToken.startOffset, startToken.endOffset) }
    | del_t_atom
del_t_atom[expr_ty]:
    | a=NAME { this.setExprContext(a, ExprContext.Delete) }
    | '(' a=del_target ')' { this.setExprContext(a, ExprContext.Delete) }
    | '(' a=[del_targets] ')' { factory.createTuple(a, ExprContext.Delete, startToken.startOffset, startToken.endOffset) }
    | '[' a=[del_targets] ']' { factory.createList(a, ExprContext.Delete, startToken.startOffset, startToken.endOffset) }

targets[asdl_expr_seq*]: a[asdl_expr_seq*]=','.target+ [','] { a }
target[expr_ty] (memo):
    | a=t_primary '.' b=NAME !t_lookahead { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Store, startToken.startOffset, startToken.endOffset) }
    | a=t_primary '[' b=slices ']' !t_lookahead { factory.createSubscript(a, b, ExprContext.Store, startToken.startOffset, startToken.endOffset) }
    | t_atom
t_primary[expr_ty]:
    | a=t_primary '.' b=NAME &t_lookahead { factory.createGetAttribute(a, ((ExprTy.Name)b).id, ExprContext.Load, startToken.startOffset, startToken.endOffset) }
    | a=t_primary '[' b=slices ']' &t_lookahead { factory.createSubscript(a, b, ExprContext.Load, startToken.startOffset, startToken.endOffset) }
    | a=t_primary b=genexp &t_lookahead {
        factory.createCall(a, new ExprTy[] {b}, EMPTY_KWDS, startToken.startOffset, endToken.endOffset) }
    | a=t_primary '(' b=[arguments] ')' &t_lookahead {
            factory.createCall(a, b != null ? ((ExprTy.Call)b).args : EMPTY_EXPR, b != null ? ((ExprTy.Call)b).keywords : EMPTY_KWDS, startToken.startOffset, endToken.endOffset ) 
        }
    | a=atom &t_lookahead { a }
t_lookahead: '(' | '[' | '.'
t_atom[expr_ty]:
    | a=NAME { _PyPegen_set_expr_context(p, a, Store) }
    | '(' a=target ')' { _PyPegen_set_expr_context(p, a, Store) }
    | '(' b=[targets] ')' { _PyAST_Tuple(b, Store, EXTRA) }
    | '[' b=[targets] ']' { _PyAST_List(b, Store, EXTRA) }


# From here on, there are rules for invalid syntax with specialised error messages
invalid_arguments:
    | args ',' '*' { this.raiseSyntaxError("iterable argument unpacking follows keyword argument unpacking") }
    | a=expression for_if_clauses ',' [args | expression for_if_clauses] {
        this.raiseSyntaxErrorKnownLocation(a, "Generator expression must be parenthesized") }
    | a=args for_if_clauses { _PyPegen_nonparen_genexp_in_call(p, a) }
    | args ',' a=expression for_if_clauses {
        this.raiseSyntaxErrorKnownLocation(a, "Generator expression must be parenthesized") }
    | a=args ',' args { _PyPegen_arguments_parsing_error(p, a) }
invalid_kwarg:
    | expression a='=' {
        this.raiseSyntaxErrorKnownLocation(
            a, "expression cannot contain assignment, perhaps you meant \"==\"?") }

invalid_expression:
    # !(NAME STRING) is not matched so we don't show this error with some invalid string prefixes like: kf"dsfsdf"
    # Soft keywords need to also be ignored because they can be parsed as NAME NAME
    | !(NAME STRING | SOFT_KEYWORD) a=disjunction expression {
         this.raiseErrorKnownLocation(ParserErrorCallback.ErrorType.Syntax, a, "invalid syntax. Perhaps you forgot a comma?") }

invalid_named_expression:
    | a=expression ':=' expression {
        this.raiseSyntaxErrorKnownLocation(
            a, "cannot use assignment expressions with %s", getExprName(a)) }
    | a=NAME b='=' bitwise_or !('='|':='|',') {
        this.raiseSyntaxErrorKnownLocation(b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?") }
    | !(list|tuple|genexp|'True'|'None'|'False') a=bitwise_or b='=' bitwise_or !('='|':='|',') {
        this.raiseSyntaxErrorKnownLocation(b, "cannot assign to %s here. Maybe you meant '==' instead of '='?",
                                          getExprName(a)) }

invalid_assignment:
    | a=invalid_ann_assign_target ':' expression {
        this.raiseSyntaxErrorKnownLocation(
            a,
            "only single target (not %s) can be annotated",
            getExprName(a)
        )}
    | a=star_named_expression ',' star_named_expressions* ':' expression {
        this.raiseSyntaxErrorKnownLocation(a, "only single target (not tuple) can be annotated") }
    | a=expression ':' expression {
        this.raiseSyntaxErrorKnownLocation(a, "illegal target for annotation") }
    | (star_targets '=')* a=star_expressions '=' {
        this.raiseSyntaxErrorInvalidTarget(TargetsType.STAR_TARGETS, a) }
    | (star_targets '=')* a=yield_expr '=' { this.raiseSyntaxErrorKnownLocation(a, "assignment to yield expression not possible") }
    | a=star_expressions augassign (yield_expr | star_expressions) {
        this.raiseSyntaxErrorKnownLocation(
            a,
            "'%s' is an illegal expression for augmented assignment",
            getExprName(a)
        )}
invalid_ann_assign_target[expr_ty]:
    | list
    | tuple
    | '(' a=invalid_ann_assign_target ')' { a }
invalid_del_stmt:
    | 'del' a=star_expressions {
        this.raiseSyntaxErrorInvalidTarget(TargetsType.DEL_TARGETS, a) }
invalid_block:
    | NEWLINE !INDENT { RAISE_INDENTATION_ERROR("expected an indented block") }
invalid_primary:
    | primary a='{' { this.raiseSyntaxErrorKnownLocation(a, "invalid syntax") }
invalid_comprehension:
    | ('[' | '(' | '{') a=starred_expression for_if_clauses {
        this.raiseSyntaxErrorKnownLocation(a, "iterable unpacking cannot be used in comprehension") }
    | ('[' | '{') a=star_named_expression ',' [star_named_expressions] for_if_clauses {
        this.raiseSyntaxErrorKnownLocation(a, "did you forget parentheses around the comprehension target?") }
invalid_dict_comprehension:
    | '{' a='**' bitwise_or for_if_clauses '}' {
        this.raiseSyntaxErrorKnownLocation(a, "dict unpacking cannot be used in dict comprehension") }
invalid_parameters:
    | param_no_default* invalid_parameters_helper param_no_default {
        this.raiseSyntaxError("non-default argument follows default argument") }
invalid_parameters_helper: # This is only there to avoid type errors
    | a=slash_with_default { new SlashWithDefault[] {a} }
    | param_with_default+
invalid_lambda_parameters:
    | lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default {
        this.raiseSyntaxError("non-default argument follows default argument") }
invalid_lambda_parameters_helper:
    | a=lambda_slash_with_default { new SlashWithDefault[] {a} }
    | lambda_param_with_default+
invalid_star_etc:
    | '*' (')' | ',' (')' | '**')) { this.raiseSyntaxError("named arguments must follow bare *") }
    | '*' ',' TYPE_COMMENT { this.raiseSyntaxError("bare * has associated type comment") }
invalid_lambda_star_etc:
    | '*' (':' | ',' (':' | '**')) { this.raiseSyntaxError("named arguments must follow bare *") }
invalid_double_type_comments:
    | TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT {
        this.raiseSyntaxError("Cannot have two type comments on def") }
invalid_with_item:
    | expression 'as' a=expression &(',' | ')' | ':') {
        this.raiseSyntaxErrorInvalidTarget(TargetsType.STAR_TARGETS, a) }

invalid_for_target:
    | ASYNC? 'for' a=star_expressions {
        this.raiseSyntaxErrorInvalidTarget(TargetsType.FOR_TARGETS, a) }

invalid_group:
    | '(' a=starred_expression ')' {
        this.raiseSyntaxErrorKnownLocation(a, "cannot use starred expression here") }
    | '(' a='**' expression ')' {
        this.raiseSyntaxErrorKnownLocation(a, "cannot use double starred expression here") }
invalid_import_from_targets:
    | import_from_as_names ',' {
        this.raiseSyntaxError("trailing comma not allowed without surrounding parentheses") }

invalid_with_stmt:
    | [ASYNC] 'with' ','.(expression ['as' star_target])+ &&':'
    | [ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' &&':'

invalid_except_block:
    | 'except' a=expression ',' expressions ['as' NAME ] ':' {
        this.raiseSyntaxErrorKnownLocation(a, "exception group must be parenthesized") }
    | 'except' expression ['as' NAME ] &&':'
    | 'except' &&':'

invalid_match_stmt:
    | "match" subject_expr !':' { CHECK_VERSION(void*, 10, "Pattern matching is", this.raiseSyntaxError("expected ':'") ) }
invalid_case_block:
    | "case" patterns guard? !':' { this.raiseSyntaxError("expected ':'") }
invalid_if_stmt:
    | 'if' named_expression NEWLINE { this.raiseSyntaxError("expected ':'") }
invalid_elif_stmt:
    | 'elif' named_expression NEWLINE { this.raiseSyntaxError("expected ':'") }
invalid_while_stmt:
    | 'while' named_expression NEWLINE { this.raiseSyntaxError("expected ':'") }

invalid_double_starred_kvpairs:
    | ','.double_starred_kvpair+ ',' invalid_kvpair
    | expression ':' a='*' bitwise_or { this.raiseSyntaxErrorKnownLocation(a, "cannot use a starred expression in a dictionary value") }
    | expression a=':' &('}'|',') { this.raiseSyntaxErrorKnownLocation(a, "expression expected after dictionary key and ':'") }
invalid_kvpair:
    | a=expression !(':') {
        this.raiseErrorKnownLocation(ParserErrorCallback.ErrorType.Syntax, a, "':' expected after dictionary key") }
    | expression ':' a='*' bitwise_or { this.raiseSyntaxErrorKnownLocation(a, "cannot use a starred expression in a dictionary value") }
    | expression a=':' {this.raiseSyntaxErrorKnownLocation(a, "expression expected after dictionary key and ':'") }
